### 命名规则

##### 包名的命名规则

包名必须全部小写。

##### 文件名的命名规则

1. 文件名必须全部小写；

2. 文件名如果有多个部分组成，那么必须使用英文状态下的`_`将其拼接。

##### 函数名的命名规则

函数名的命名遵循小驼峰或大驼峰的命名规则。

##### 标识符的命名规则

1. 首字符必须是字母或下划线，其他字符可以是数字、字母或下划线；

2. 不允许是Go关键字。

> 附：可见性规则
>
> 1. 首字母大写，包内外可见；
>
> 2. 首字母小写，包内可见。

##### 标签名的命名规则

标签名必须全部大写。

### 基本结构

##### `package`作用

`package`主要用于声明该文件属于哪个包。

> 注：
>
> 当`package main`时，那么表示的是该文件是一个可独立执行的程序。

##### 导入包

```go
import (
    别名 "包名"
    ...
)
```

##### 执行

* 直接执行

    ```go
    go run ./文件名
    ```

* 先编译后执行

    * 编译

        ```go
        go build ./文件名
        ```

    * 执行

        ```go
        ./文件名
        ```

### 变量

##### 定义及其初始化

* 显示定义(一般用于声明全局变量)

    ```go
    var (
        变量名1, ... 数据类型 = 初始值1, ...
        ...
    )
    ```

    > 注：
    >
    > 当使用`var`定义变量时，那么该变量会自动被初始化该变量所对应数据类型的零值。

* 隐式定义

    ```go
    var (
        变量名1, ... = 初始值1, ...
        ...
    )
    ```

* 简短定义(一般用于声明局部变量)

    ```go
    变量名1, ... := 初始值1, ...
    ```

##### 匿名变量

* 概述

    匿名变量是一个空白标识符`_`。

* 特点

    1. 匿名变量可以被重复声明；
    
    2. 匿名变量不占用内存空间；

    3. 匿名变量的值不可以被使用。

##### 变量类型及其作用域

* 全局变量

    全局变量是定义在函数体外的变量，可以在整个包或包外使用。

* 局部变量

    局部变量是定义在函数体内的变量，只可以在该函数体内使用。

* 形式参数

    形式参数是定义函数时使用的变量，只可以在该函数体内使用。

    > 注：
    >
    > 形式参数也属于局部变量。

### 常量

常量的定义方式和变量的定义方式基本一致，只需要将`var`换成`const`即可。

### 注释

##### 单行注释

```go
// 注释
```

##### 多行注释

```go
/*
注释
...
*/
```

### 数据类型

##### 基本类型

```go
string
uint8 0~255
int8 -128~127
uint16 0~65535
int16 -32768~32768
uint32 0~42亿
int32 -21亿~21亿
uint64
int64
uint uint32或uint64
int int32或int64
float32
float64
true
false
```

##### 结构化类型

```go
array
slice
map
struct
channel
```

##### 描述类型行为的类型

```go
interface
```

##### 类型别名

```go
type (
    别名 数据类型
    ...
)
```

### 常用运算符

##### 算术运算符

```go
+
-
*
/
%
```

##### 赋值运算符

```go
=
```

##### 复合运算符

```go
+=
-=
*=
/=
%=
```

##### 比较运算符

```go
==
!=
<
<=
>
>=
```

> 注：
>
> 比较运算符只适用于同类型数据间的比较。

##### 逻辑运算符

```go
&&
||
!
```

##### 位运算符

```go
&
|
^
<<
>>
```

### 字符串

##### 分类

* 解释性字符串

    解释性字符串必须使用英文状态下的双引号将其括起来；

* 非解释性字符串

    非解释性字符串必须使用英文状态下的反引号将其括起来。

##### (理解)字符串在内存中的表现

字符串在内存中不仅是一个字节数组，而且编译器还给他分配了一个头部字段来存储指向底层字节数组的指针和长度信息，所以当我面将一个变量的值赋值给另一个变量时，那么它只是浅拷贝了头部字段，而底层字节数组是共享的。

##### 创建

```go
var 字符串变量名 string = "字符串"
```

> 附：字符串变量的域
>
> 1. 指向底层字节数组的指针；
>
> 2. 底层字节数组的长度信息。

##### 访问指定位置的字节

```go
字符串变量名[下标]
```

##### 切割

```go
字符串变量名[[start]: [end]]
```

> 注：
>
> 1. 当`start`或`end`省略时，那么默认为开始于字符串首或结束于字符串末端，遵循差一行为；
>
> 2. 当对字符串进行切割时，那么实际上是对底层字节数组进行切割，所以它们共享底层字节数组。

##### 拼接

```go
字符串变量名1 + ...
```

##### 字符串和字节切片的相互转换

* 字符串转字节切片

    ```go
    []byte(字符串变量名)
    ```

* 字节切片转字符串

    ```go
    string(字节切片变量名)
    ```

##### 常用方法

##### 计算字符串的字节长度

```go
len(字符串变量名)
```

##### 遍历

* 按`byte`遍历

    ```go
    for i := 0; i < len(字符串变量名); i++ {
        ...
    }
    ```

* 按`rune`遍历

    ```go
    for codePoint, runeValue := range 字符串变量名 {
        ...
    }
    ```

### `strings`包

##### 重复字符串

```go
strings.Repeat(字符串变量名, 重复次数)
```

##### 字符串之间的比较

```go
strings.Compare(字符串变量名1, 字符串变量名2)
```

##### 修改字符串中字母的大小写

```go
strings.Title/ToUpper/ToLower(字符串变量名)
```

##### 统计指定子字符串在原字符串中出现的次数

```go
strings.Count(字符串变量名, 子字符串变量名)
```

##### 判断指定子字符串是否存在于原字符串中，如果存在，那么返回该子字符串在原字符串中第一次或最后一次出现位置的码位，如果不存在，那么返回`-1`

```go
strings.Index/LastIndex(字符串变量名, 子字符串变量名)
```

##### 判断给定字符串是否以指定子字符串开头或结尾

```go
strings.HasPrefix/HasSuffix(字符串变量名, 子字符串变量名)
```

##### 判断原字符串是否包含子字符串

```go
strings.Contains(字符串变量名, 子字符串变量名)
```

##### 按指定字符分割给定字符串

```go
strings.Split(字符串变量名, "分隔符")
```

##### 按指定字符替换给定字符串中的字符

```go
strings.Replace(字符串变量名, 被替换的字符, 替换的字符, 替换次数)
```

> 注：
>
> 当`替换次数=-1`时，那么默认为替换所有。

##### 删除给定字符串中的指定字符

```go
strings.Trim/TrimLeft/TrimRight(字符串, "字符")
```

### `time`包

##### `time.Time`对象和秒数或格式化字符串间的相互转换

```go
time.Now()
time.Time对象名.Unix/UnixNano()
time.Unix(秒数, 纳秒数)
time.Time对象名.Format("2006-01-02 15:04:05")
time.Time对象名, err := time.Parse("2006-01-02 15:04:05", 格式化字符串)
```

##### 获取`time.Time`对象的年/月/日/时/分/秒/纳秒/已过去的天数

```go
time.Time对象名.Year/Month/Day/Hour/Minute/Second/Nanosecond/YearDay()
```

##### `time.Time`对象间的比较

```go
time.Time对象名1.After/Before/Equal(time.Time对象名2)
```

##### `time.Time`对象追加指定`Duration`数

```go
time.Time对象名.Add(Duration数)
```

> 释：
>
> `Duration`数也就是`time.Hour/Minute/Second/Millisecond/Microsecond/Nanosecond * n`

##### `time.Time`对象间相减

```go
time.Time对象名1.Sub(time.Time对象名2)
```

##### 阻塞当前进程`Duration`数

### 指针

##### 概念

指针是指向某一个值的内存地址。

> 注：
>
> 指针不可以指向字面量或常量的内存地址。

##### 定义

* 常规指针

    ```go
    var 指针变量名 *数据类型
    ```

* `n`重指针

    ```go
    var 指针变量名 [n个]*数据类型
    ```

##### 赋值

```go
指针变量名 = &变量名/指针变量名
```

##### 访问指针变量所指向的值

* 常规指针

    ```go
    *指针变量名
    ```

* `n`重指针

    ```go
    [n个]*数据类型
    ```

##### 空指针

空指针是一个已定义未赋值的指针，它的默认值为`nil`。

### 分支语句

##### `if-else`语句

* 单条件判断语句

    ```go
    if [初始化语句;] 条件语句 {
        ...
    }
    ```

* 多条件判断语句

    ```go
    if [初始化语句;] 条件语句 &&/|| 条件语句 ... {
        ...
    }
    ```

##### `switch`语句

* 值匹配

    ```go
    switch 取值表达式 {
        case 值1, ...:
            ...
        ...
        default:
            ...
    }
    ```

    > 注：
    >
    > 由于默认情况下，`switch`语句中每一个`case`最后都会带有一个`break`，所以当我们希望匹配成功以后继续执行下一个`case`时，那么必须使用`fallthrough`来实现。

* 表达式匹配

    ```go
    switch {
        case 条件表达式:
            ...
        ...
        default:
            ...
    }
    ```

### 循环语句

##### 创建

* 和C语言中的`for`一样

    ```go
    for [初始化语句;] 条件语句; 修饰语句 {
        ...
    }
    ```

* 和C语言中的`while`一样

    ```go
    for [初始化语句;] 条件语句 {
        ...
    }
    ```

* `for-each range`循环

    ```go
    for i, v := range 字符串/数组/切片/map变量名 {
        ...
    }
    ```

##### 控制

* `break 标签名`

    * 不使用标签名

        跳出`break`所在的循环。

    * 使用标签名

        跳出标签名标记的循环。

* `continue 标签名`

    * 不使用标签名

        结束本次`continue`所在的循环。

    * 使用标签名

        结束本次标签名标记的循环。

* `goto 标签名`

    跳转到标签名标记的循环。