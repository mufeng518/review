### 常规函数

##### 定义函数类型别名

```go
type 别名 func(数据类型, ...) [返回值的数据类型/(返回值的数据类型, ...)]
```

##### 创建

```go
func 函数名(形参1 数据类型, ...) [(返回值1 返回值的数据类型, ...)] {
    ...
}
```

##### 调用

```go
函数名(实参1, ...)
```

##### 传参方式

* 值传递

    值传递是调用函数时将实参拷贝一份传递到该函数体内。

* 引用传递

    引用传递是调用函数时将实参的内存地址拷贝一份传递到该函数体内。

##### `defer`用法

`defer`主要用于在函数`return`之前执行某一个语句或函数。

> 注：
>
> 当一个函数中有多个`defer`时，那么遵循先进后出原则。

### 变参函数

##### 创建

```go
func 函数名(形参1 数据类型, ..., 形参n ...数据类型) [(返回值1 返回值的数据类型, ...)] {
    ...
}
```

> 注：
>
> 变参必须放置在参数序列的末端。

##### 调用

* 常规调用

    ```go
    函数名(实参1, ...)
    ```

* 切片调用

    ```go
    函数名(实参1, ..., 切片变量名...)
    ```

### 匿名函数

##### 创建

```go
变量名 = func(形参1 数据类型, ...) [(返回值1 数据类型, ...)] {
    ...
}
```

##### 调用

```go
变量名(实参1, ...)
```

### 闭包

##### 创建

```go
func 函数名(形参1 数据类型, ...) func(数据类型, ...) [返回值的数据类型/(返回值的数据类型, ...)] {
    ...
    return func(形参1 数据类型, ...) [(返回值, 返回值的数据类型, ...)] {
        ...
    }
}
```

### 数组

##### 概述

数组是由一系列同类型、已编号且长度固定的元素组成的序列。

##### 创建

* 常规创建

    ```go
    var 数组变量名 [数组长度]数据类型
    ```

* 指定下标创建

    ```go
    var 数组变量名 [数组长度]数据类型 = [数组长度]数据类型{下标:元素1, ...}
    ```

* `new`创建

    ```go
    var 数组变量名 *[数组长度]数据类型 = new([数组长度]数据类型)
    ```

##### 添加或修改

```go
数组变量名[下标] = 新元素
```

##### 访问

```go
数组变量名[下标]
```

##### 数组赋值条件

1. 类型相同；

2. 长度相同。

> 注：
>
> Go语言中的赋值是值拷贝。

##### 多维数组

* 创建

    ```go
    var 数组变量名 [数组长度]...数据类型
    ```

* 访问

    ```go
    数组变量名[下标]...
    ```

### 切片

##### 概述

切片是对数组一个连续片段的引用，是一个引用类型。

##### 创建

* `nil`切片

    ```go
    var 切片变量名 []数据类型
    ```

    > 附：切片变量包含的域
    >
    > 1. 指向底层数组的指针；
    >
    > 2. 切片的初始长度；
    >
    > 3. 切片的容量。

* 空值切片

    ```go
    var 切片变量名 []数据类型 = []数据类型{}
    ```

* 零值切片

    ```go
    var 切片变量名 []数据类型 = make([]数据类型, 初始长度[, 切片容量])
    ```

    > 注：
    >
    > 当`切片容量`省略时，那么默认为`切片容量=初始长度`。

##### 访问

```go
切片变量名[下标]
```

##### 修改

* 单个

    ```go
    切片变量名[下标] = 新元素
    ```

* 多个

    ```go
    copy(目标切片变量名, 源切片变量名)
    ```

    > 注：
    >
    > 当`源切片变量名`和`目标切片变量名`的长度不一致时，那么遵循从小原则。

##### 追加

```go
append(切片变量名, 新元素1, .../切片变量名...)
```

> 注：
>
> 当对一个切片进行追加元素时，如果追加后切片没有扩容，那么追加前后的两个切片共享底层数组，如果追加后切片有扩容，那么追加前后的两个切片是分离的、不共享的。

##### 切割

```go
切片变量名[[start]:[end]]
```

> 注：
>
> 1. 当对一个切片进行切割时，那么实际上是对底层数组进行切割，所以共享底层数组；
>
> 2. 当对一个切片进行切割时，那么切割前后的长度、容量是会改变的。

##### 常用方法

* 计算切片的长度或容量

    ```go
    len/cap(切片变量名)
    ```

* 将切片转换成字符串

    ```go
    strings.Join(切片变量名, "拼接符")
    ```

    > 注：
    >
    > 切片变量中的元素必须是`string`。