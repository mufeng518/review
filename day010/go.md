### 命名规则

##### 包名的命名规则

包名必须全部小写。

##### 文件名的命名规则

1. 文件名必须全部小写；

2. 文件名如果有多个部分组成，那么必须使用英文状态下的`_`进行拼接。

##### 函数名的命名规则

函数的命名遵循小驼峰或大驼峰的命名规则。

##### 标识符的命名规则

1. 首字符必须是字母或下划线，其他字符可以是数字、字母或下划线；

2. 不允许是Go关键字。

##### 标签名的命名规则

标签名必须全部大写。

### 基本结构

##### `package`作用

`package`主要用于声明该文件属于哪个包。

> 注：
>
> 当`package main`时，那么表示的是该文件是一个可独立执行的程序。

##### 导入包

```go
import (
    别名 "包名"
    ...
)
```

##### 执行

* 直接执行

```go
go run ./文件名
```

* 先编译后执行

    * 编译

        ```go
        go build ./文件名
        ```

    * 执行

        ```go
        ./文件名
        ```

### 变量

##### 定义及其初始化

* 显示定义(一般用于声明全局变量)

    ```go
    var (
        变量名1, ... 数据类型 = 初始值1, ...
        ...
    )
    ```

* 隐式定义

    ```go
    var (
        变量名1, ... = 初始值1, ...
        ...
    )
    ```

* 简短定义(一般用于声明局部变量)

    ```go
    变量名1, ... := 初始值1, ...
    ```

##### 匿名变量

* 概述

    匿名变量是一个空白标识符`_`。

* 特点

    1. 匿名变量不占用内存空间；

    2. 匿名变量可以被重复声明；

    3. 匿名变量的值不可以被使用。

##### 变量类型及其作用域

* 全局变量

    全局变量是定义在函数体外的变量，可以在整个包或包外使用。

* 局部变量

    局部变量是定义在函数体内的变量，只可以在该函数体内使用。

* 形式参数

    形式参数是定义函数时使用的变量，只可以在该函数体内使用。

    > 注：
    >
    > 形式参数也属于局部变量。

### 常量

常量的定义方式基本和变量的定义方式一致，只需将`var`换成`const`即可。

### 注释

##### 单行注释

```go
// 注释
```

##### 多行注释

```go
/*
注释
...
*/
```

### 数据类型

##### 基本类型

```go
string
int8 -128~127
uint8 0~255
int16 -32768~32767
uint16 0~65535
int32 -21亿~21亿
uint32 0~42亿
int64
uint64
int int32 int64
uint int32 uint64
float32  // 保留到小数点后7位
float64  // 保留到小数点后15位
true
false
```

##### 结构化类型

```go
array
slice
map
struct
channel
```

##### 描述类型行为的类型

```go
interface
```

##### 类型别名

```go
type (
    别名 数据类型
    ...
)
```

### 常用运算符

##### 算术运算符

```go
+
-
*
/
%
```

##### 赋值运算符

```go
=
```

##### 复合运算符

```go
+=
-=
*=
/=
%=
```

##### 比较运算符

```go
==
!=
>
>=
<
<=
```

> 注：
>
> 比较运算符只适用于同类型数据间的比较。

##### 逻辑运算符

```go
&&
||
!
```

##### 位运算符

```go
&
|
^
<<
>>
```

### 字符串

##### 分类

* 解释性字符串

    解释性字符串是使用英文状态的双引号括起来的标识符。

* 非解释性字符串

    非解释性字符串是使用英文状态下的反引号括起来的字符串。

##### (理解)字符串在内存中的表现

字符串在内存中不仅是一个字节数组，而且编译器还给他分配了一个头部字段来存储执行底层字节数组的指针和长度信息，所以当我讲一个变量的值赋值给另外一个变量时，那么它实际上只是浅拷贝了头部字段，而底层字节数组是共享的。

##### 创建

```go
var 字符串变量名 string = "字符串"
```

> 附：字符串变量包含的域
>
> 指向底层字节数组的指针和底层字节数组的长度信息。

##### 访问指定位置的`unicode`编码

```go
字符串变量名[下标]
```

##### 切割

```go
字符串变量名[[start]: [end]]
```

> 注：
>
> 1. 当`start`或`end`省略时，那么默认为开始于字符串首端或结束于字符串末端，遵循差一行为；
>
> 2. 当对字符串进行切割时，那么实际上是对底层字节数组进行切割，所以它们共享底层字节数组。

##### 拼接

```go
字符串变量名1 + ...
```

##### 字符串和字节切片的相互转换

* 字符串转字节切片

    ```go
    []tyte(字符串变量名)
    ```

* 字节切片转字符串

    ```go
    string(字节切变量名)
    ```

##### 常用方法

##### 计算字符串的字节长度

```go
len(字符串变量名)
```

##### 遍历

* 按`byte`遍历

    ```go
    for i := 0; i < len(字符串变量名); i++ {
        ...
    }
    ```

* 按`rune`遍历

    ```go
    for codePoint, runeValue := range 字符串变量名 {
        ...
    }
    ```

### `strings`包

##### 重复字符串

```go
strings.Repeat(字符串变量名, 重复次数)
```

##### 字符串之间的比较

```go
strings.Compare(字符串变量名1, 字符串变量名2)
```

##### 修改字符串中字母的大小写

```go
strings.Title/ToUpper/ToLower(字符串变量名)
```

##### 统计指定子字符串在原字符串中出现的次数

```go
strings.Count(字符串变量名, "子字符串")
```

##### 判断指定子字符串是否存在于原字符串中，如果存在，那么返回该子字符串在原字符串中第一次或最后一次出现位置的码位，如果不存在，那么返回`-1`

```go
strings.Index/LastIndex(字符串变量名, "子字符串")
```

##### 判断给定字符串是否以指定子字符串开头或结尾

```go
strings.HasPrefix/HasSuffix(字符串变量名, "子字符串")
```

##### 判断原字符串是否包含子字符串

```go
strings.Contains(字符串变量名, "子字符串")
```

##### 按指定字符分割给定字符串

```go
strings.Split(字符串变量名, "字符“)
```

##### 按指定字符替换给定字符串中的字符

```go
strings.Replace(字符串变量名, "被替换的字符", "替换的字符", 替换次数)
```

> 注：
>
> 当`替换次数=-1`时，那么默认为替换所有。

##### 删除给定字符串中的指定字符

```go
strings.Trim/TrimLeft/TrimRight(字符串变量名, "字符")
```

### `time`包

##### `time.Time`对象和秒数或格式化字符串间的相互转换

```go
time.Now()

time.Time对象名.Unix/UnixNano()
time.Unix(秒数， 纳秒数)

time.Time对象名.Format("2006-01-02 15:04:05")
time.Time对象名, err := time.Parse("2006-01-02 15:04:05", 格式化字符串)
```

##### 获取`time.Time`对象的年/月/日/时/分/秒/纳秒/已过去的天数

```go
time.Time对象名.Year/Month/Day/Hour/Minute/Second/Nanosecond/YearDay()
```

##### `time.Time`对象间的比较

```go
time.Time对象名1.Before/After/Equal(time.Time对象名2)
```

##### `time.Time`对象追加指定`Duration`数

```go
time.Time对象名.Add(Duration数)
```

> 释：
>
> `Duration数`也就是`time.Hour/Minute/Second/Millisecond/Microseond/Nanosecond`。

##### `time.Time`对象间相减

```go
time.Time对象名1.Sub(time.Time对象名2)
```

##### 阻塞当前进程`Duration`数

```go
time.Sleep(Duration数)
```

### 指针

##### 概念

指针是指向某一个值的内存地址。

> 注：
>
> 指针不可以指向字面量、常量或切片的内存地址。

##### 定义

* 常规指针

    ```go
    var 指针变量名 *数据类型
    ```

* `n`重指针

    ```go
    var 指针变量名 [n个]*数据类型
    ```

##### 赋值

```go
var 指针变量名 = &变量名/指针变量名
```

##### 访问指针变量所指向的值

* 常规指针

    ```go
    *指针变量名
    ```

* `n`重指针

    ```go
    [n个]*指针变量名
    ```

##### 空指针

空指针是一个已定义未赋值的指针。

### 分支语句

##### `if-else`语句

* 单条件判断语句

    ```go
    if [初始化语句;] 条件语句 {
        ...
    } else if 条件语句 {
        ...
    } else {
        ...
    }
    ```

* 多条件判断语句

    ```go
    if [初始化语句;] 条件语句1 &&/|| ... {
        ...
    } else {
        ...
    }
    ```

##### `switch`语句

* 值匹配

```go
switch 取值表达式 {
    case 值1, ...:
        ...
    ...
    default:
        ...
}
```

> 注：
>
> 由于默认情况下，`switch`语句中每一个`case`最后都会有一个`break`，所以当我们希望匹配成功以后继续执行下一个`case`时，那么必须使用`fallthrough`来实现。

* 表达式匹配

```go
switch {
    case 条件语句1:
        ...
    ...
    default:
        ...
}
```

### 循环语句

##### 创建

* 和C语言中的`for`一样

    ```go
    for 初始化语句; 条件语句; 修饰语句 {
        ...
    }
    ```

* 和C语言中的`while`一样

    ```go
    for 条件语句 {
        ...
    }
    ```

* `for-each range`循环

    ```go
    for i, v := range 字符串/数组/切片/map变量 {
        ...
    }
    ```

##### 控制

* `break 标签名`

    * 不使用标签名

        跳出`break`所在的循环。

    * 使用标签名
        跳出标签名标记的循环。

* `continue 标签名`

    * 不使用标签名

        结束本次`continue`所在的循环。

    * 使用标签名

        结束本次标签名标记的循环。

* `goto 标签名`

    跳转到标签标记的位置。